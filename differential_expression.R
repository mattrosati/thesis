#   Differential expression analysis with limma
#   Generated by GeoR, processes any normalized Geo Series!!

source('packages.R')

# load series and platform data from GEO. Input is cell type string, output is gset
load <- function(x) {

  chosen <- x #cell type data to fetch
  series <- toString(all_series[all_series$Cell == chosen, 2])
  platform <- toString(all_series[all_series$Cell == chosen, 3])
  
  gset <- getGEO(series, GSEMatrix =TRUE, AnnotGPL=TRUE)
  if (length(gset) > 1) idx <- grep(platform, attr(gset, "names")) else idx <- 1
  gset <- gset[[idx]]
  
  # make proper column names to match toptable 
  fvarLabels(gset) <- make.names(fvarLabels(gset))
  
  # group names for all samples
  gsms <- toString(all_series[all_series$Cell == chosen, 4]) #string where 1 indicates test sample, 0 indicates control sample, and X indicates unnecessary.
  sml <- c()
  for (i in 1:nchar(gsms)) { sml[i] <- substr(gsms,i,i) }
  
  # eliminate samples marked as "X"
  sel <- which(sml != "X")
  sml <- sml[sel]
  gset <- gset[ ,sel]
  
  # log2 transform
  ex <- exprs(gset)
  qx <- as.numeric(quantile(ex, c(0., 0.25, 0.5, 0.75, 0.99, 1.0), na.rm=T))
  LogC <- (qx[5] > 100) ||
    (qx[6]-qx[1] > 50 && qx[2] > 0) ||
    (qx[2] > 0 && qx[2] < 1 && qx[4] > 1 && qx[4] < 2)
  if (LogC) { ex[which(ex <= 0)] <- NaN
  exprs(gset) <- log2(ex) }
  
  # set up the data and proceed with analysis
  sml <- paste("G", sml, sep="")    # set group names
  fl <- as.factor(sml)
  gset$description <- fl
  
  return(gset)

}

#check low intensity probes
tran <- log2(exprs(gset))
medians <- rowMedians(Biobase::exprs(gset))
hist_res <- hist(medians, 100, col = "cornsilk1", freq = FALSE, 
                 main = "Histogram of the median intensities", 
                 border = "antiquewhite4",
                 xlab = "Median intensities")

#remove duplicate symbols!!
#gset <- featureFilter(gset, require.entrez=FALSE, require.GOBP=FALSE, 
#                        require.GOCC=FALSE, require.GOMF=FALSE, 
#                        require.CytoBand=FALSE, remove.dupEntrez=FALSE, 
#                        feature.exclude="^AFFX")

#remove values with no symbol and multiple mappings, figure this out later!
#gset <- subset(gset, !is.na(Gene.symbol))

#checks for blocking in groups with paired biological replicates. input is gset, returns design.
blocking <- function(x) {
  if (chosen == "Microglial") {
    titles <- as.character(pData(x)$title)
    populations <- c("B18", "O", "W", "Y20", "B18", "O", "W", "Y20")
    populations <- as.factor(populations)
    col <- as.factor( c( levels(fl), levels(populations) ) )
  } else if (chosen == "Thyroid" | chosen == "Keratinocyte") {
    populations <- factor(c(1, 1, 2, 2, 3, 3))
  } else if (chosen == "AALEB" | chosen == "Hepatocyte") {
    populations <- factor(c(1, 2, 1, 2))
  } else if (chosen == "Fibroblast") {
    populations <- factor(c(1, 2, 3, 1, 2, 3))
  }
    
  
  #Run analysis
  if (!(chosen == "ARPE" | chosen == "HSG")) {
    design <- model.matrix(~ description + 0 + populations, x)
  } else {
    design <- model.matrix(~ description + 0, x)
  }
  return(design)
}

# runs linear model. input is gset and design, output is topTable
p.vals <- function(gset, design) {
  fit <- lmFit(gset, design)
  cont.matrix <- makeContrasts(descriptionG1-descriptionG0, levels=design)
  fit2 <- contrasts.fit(fit, cont.matrix)
  fit2 <- eBayes(fit2)
  tT <- topTable(fit2, adjust="fdr", sort.by="B", number=Inf)
  
  tT <- subset(tT, select=c("ID","adj.P.Val","P.Value","t","B","logFC","Gene.symbol","Gene.title", "GO.Function.ID", "GO.Process.ID", "GO.Component.ID"))
  
  #sort by p value and log fold change, remove duplicates
  tT.sort <- tT[order(-abs(tT$logFC), tT$adj.P.Val),]
  tT.sort <- tT.sort[!duplicated(tT.sort$Gene.symbol),]
}


of_interest_fold <- as.integer(nrow(tT[abs(tT$logFC) > 1,]))
of_interest <- as.integer(nrow(tT[tT$adj.P.Val <= 0.1 & abs(tT$logFC) >= 1, ]))

print(c(of_interest))
hist(tT$P.Value)


supp <- as.integer(nrow(tT.sort[tT.sort$adj.P.Val <= 0.1 & tT.sort$logFC < 0, ]))
act <- as.integer(nrow(tT.sort[tT.sort$adj.P.Val <= 0.1 & tT.sort$logFC > 0, ]))

print(c(supp, act))

#make final and save
final <- tT.sort[,-1]
path <- paste("~/Desktop/MacMicking Lab/IFN_microarray/Processed Data/", tolower(chosen), "f.csv", sep = "")
write.csv(final, file = path)

}



